---
kind: impl_notes
scope: iori-spec
spec_title: "iori-spec Design Notes & TODOs"
status: draft
---

# iori-spec Design Notes & TODOs

## iori-spec の思想

- LLM が効率的・高品質にシステム開発できるようにしたい
- LLM ＋ツールでシステム開発するための“環境”を作る
- 手段としての SDD（Specification-Driven Development）

  - LLM にとって扱いやすい SDD
  - LLM にとっての高効率・高品質な仕様書

    - マクロ視点の品質：構造・トレース・SSoT・ディレクトリ役割
    - ミクロ視点の品質：「REQ ブロックの書き方（良い悪い例）」や「解釈しやすい文章スタイル」
- LLM をサポートするツール

  - ツールと LLM の役割分担の線引きおよびツールが提供すべき機能を明確にする

    - ツールの役割：構造・依存・コンテキストの絞り込み
    - LLMの役割：意味的な矛盾検出・設計判断

### 0. Brief

iori-spec の思想の中心となる２つの目的

- 軸①. **「巨大仕様でも、LLM にとっては常に “小さい仕様を扱っている” のと同じ認知負荷に抑えたい」**
- 軸②. **「健全な構造の仕様・システムになるよう誘導したい」**

### 軸①. LLM 協調・局所コンテキスト化の軸

> **巨大な仕様セットがあっても、ツールの力で「LLM からは常に小さな一部分だけを読めば済む状態」にしておきたい、という軸。**

- 仕様全体は何十・何百ファイルに分かれていてもよいが、
  **LLM にタスクを振るときには「そのタスクに本当に必要な断片だけ」を抽出して渡したい**。
- そのために、ID・依存関係・トレース情報・影響範囲をツール側で管理し、

  - 「この REQ を変えたいなら、この IF/DATA/TEST と、この数行だけ見ればいい」
    という **“局所的な仕様ビュー”** を自動で作ることを目指す。
- ねらいは、
  **巨大仕様でも、LLM にとっては常に “小さい仕様を扱っている” のと同じ認知負荷に抑えること。**

### 軸②. 設計品質・構造健全性の軸

> **関心の分離・高凝集・疎結合・抽象化・非冗長といった設計原則に従った、健全な構造の仕様・システムになるよう誘導したい、という軸。**

- システムが大きくなっても、

  - **モジュールごとに責務がはっきりしていること（高凝集）**
  - **不必要に他に依存しないこと（疎結合）**
  - **レイヤーや境界ごとに関心が分離されていること（SoC）**
  - **同じ意味のことがあちこちに重複しないこと（DRY / 非冗長）**
    を崩さないようにしたい。
- そのために、ディレクトリ構成・ID 設計・依存関係ルール・トレースルールを
  **「設計アンチパターンに落ちにくい形」で定義し、ツールと LLM からも参照できるようにしておく。**
- ねらいは、仕様の追加・変更・削除を繰り返しても、**全体として「きれいな分割」「自然な依存方向」が維持されるようにすること。**

### 2つの軸の関係性

#### 0. Brief

軸①（LLM 協調・局所コンテキスト化）と軸②（設計品質・構造健全性）は別の目的を持つが、

- **高凝集・疎結合な設計**ほど影響範囲が局所に閉じやすくなり、
- 逆に、**「局所だけを LLM に見せたい」という要請**が、責務分割や依存関係の整理を促す

──という形で、お互いを強く補強し合う関係にある。

#### 1. 「別物だけど、かなり強く連動している」

- 軸①：**LLM 協調・局所コンテキスト化**

  - 目的：巨大な仕様セットであっても、**LLM からは常に「小さな一部分だけを読めばいい」状態にすること。**
  - 手段：

    - ID・依存関係・トレース情報をツールで管理する
    - `impact`（影響範囲抽出）や `context`（LLM 向けコンテキスト生成）といったコマンドで、タスクごとに必要な仕様断片だけを切り出す

- 軸②：**設計品質・構造健全性（SoC / 高凝集 / 疎結合 / DRY など）**

  - 目的：仕様・システムが大きくなっても、**責務が明確で、依存関係が素直で、重複が少ない構造を維持すること。**
  - 手段：

    - ディレクトリ構成・ID 設計・依存方向ルール・トレースルールを明示する
    - architecture / reference / lint などでアンチパターンを防ぐ

この2つは「やっていること」は違うけれど、
**お互いの前提／ブースターとして強く連動している**。

#### 2. 軸②がしっかりしていると、軸①がうまく機能する

- 設計が高凝集・疎結合になっていると：

  - 1つの REQ / IF / DATA の責務が明確
  - 依存範囲が「自然に狭く」なる
- その結果：

  - `impact REQ-101` したときに、
    **「本当に見なきゃいけない周辺」だけがきれいに出てくる**
  - LLM に渡す `context` も、小さくて済む

→ **良い構造（軸②）があるほど、「常に小さい仕様だけを見る」ためのツール（軸①）がきれいに効く。**

#### 3. 軸①を意識すると、軸②の設計も自然と良くなる

逆向きの影響もある：

- 常に `impact` / `context` で
  「**この ID を起点に“局所世界”を切り出す**」前提で考えると、

  - 1つの ID があちこちに絡みつく設計は「扱いづらい」とすぐ分かる
  - 「この IF、ちょっと責務デカすぎない？」という違和感が出やすい
- その結果：

  - REQ/IF/DATA/TEST の分割・ID 設計を見直すモチベーションになる
  - 「影響範囲を小さく抑えられるような分割」を自然と意識するようになる

→ **「LLM に小さい局所だけ渡したい」という要請（軸①）が、結果的に SoC / 高凝集 / 疎結合（軸②）を促す方向に働く。**

## iori-spec の世界観

- 仕様とは REQ / IF / DATA / TEST / TASK の ID 付きノードの集合である
- それらの関係は
  - REQ → IF/DATA/TEST の **トレースグラフ (G_trace)**
  - IF ⇄ DATA の **Data–Process Graph (G_DP)**
  - doc 間の **ドキュメント依存グラフ (G_doc)**
    として表現される
- ツールの役割は
  - グラフを構築し、**あるノード（ID / doc）を起点に、上下流を機械的に列挙すること**
  - 「操作（追加・変更・削除）」に対して影響を受けるノードを提示すること
  - 「仕様の集合自身が、LLM と人間が仕様の集合に加えうるあらゆる操作（追加、変更、削除）について、
    その影響範囲を回答する」かのように振る舞うこと
  - 機械的に言い換えると「**ノード（ID / doc）× 操作種別（add/change/delete） → 影響を受けるノード集合**」という関数を、
    仕様＋ツールの側に持たせたいということ

## 仕様の集合自身が操作に対して影響範囲を回答するには

前提となる操作についてざっくりルールを分けるとこんな感じになる：

### 1 追加（add）

- 追加したい対象：

  - 新しい REQ / IF / DATA / TEST / TASK
  - あるいは既存 doc に新しい ID ブロックを追加
- 影響範囲の意味：

  - 「どこと整合を取る必要があるか？」
  - 例：

    - 新しい REQ → Traceability Map に行が必要
    - 新しい DATA → それを生成する IF / 消費する IF の設計が必要
- グラフ的には：

  - **近い種類のノード**（同じ kind / scope）や、
  - 同じ領域の REQ 群の neighborhood を出してあげると、
  - LLM が「既存のパターンに合わせた追加」をしやすくなる。

### 2 変更（change）

- 変更したい対象：

  - ある REQ-xxx / IF-xxx / DATA-xxx / TEST-xxx の本文
- 影響範囲の意味：

  - その ID に**直接つながっているノード**は、少なくとも目を通す必要がある。
- グラフ的には：

  - G_trace:

    - REQ-101 を変える → 行き先の IF / DATA / TEST
  - G_DP:

    - DATA-020 を変える → それを読む IF、そこから先の DATA/TEST
  - G_doc:

    - doc 単位で「どのファイルを開くべきか」

ここはまさに `impact <ID>` コマンドのど真ん中。

### 3 削除（delete）

- 削除したい対象：

  - ID 自体（REQ-101 をなくす）
  - ID ブロックを doc から削る
- 影響範囲の意味：

  - 「このノードに依存しているノードは、孤立する or 意味が変わる」
- グラフ的には：

  - **そのノードを入次数・出次数を見て、ぶら下がっているノードを全部列挙**
  - 例：

    - REQ-101 を削除 → その REQ に紐付いた IF/DATA/TEST が「孤児」になるので警告候補
    - DATA-101 を削除 → それを `consumes` している IF や TEST が影響範囲

### 4 仕様自身が答えているように見せるために必要な追加要素

#### 1 エッジの「種類」と「強さ」

今は「REQ → IF」みたいに単純なエッジで考えているけど、
将来的には少しだけラベルがあると良いかも。

- 例：

  - REQ → IF（implements）
  - REQ → TEST（verifies）
  - IF → DATA（produces / consumes）
  - TEST → DATA（uses-as-input）

これがあると、

- 「削除時に絶対に見なきゃいけないノード」
- 「追加時に“参照候補”として眺めておきたいノード」

を優先度付きで並べられる。

#### 2 操作種別をコマンドとして直接扱う

例えば将来的に：

```bash
iori-spec impact --op change REQ-101
iori-spec impact --op delete DATA-020
```

みたいにすると、

- `--op change` → 直接接続ノード + 同じ doc の関連ブロック
- `--op delete` → 依存しているノード（入次数側）を重めに出す
- `--op add` → 同 scope / 近い ID を「参照候補」として出す

みたいな**操作種別ごとのプリセットロジック**を仕込める。

LLM から見ると：

> 「いまやりたい操作を指定して `impact` を叩けば、
> “そこだけ読めばいい局所世界” を返してくる箱」

になる。

#### 3 context の「編集単位」最適化

今話しているゴールって、要するに

> 仕様全体がでかくても、**LLM に渡すのは常に“小さな仕様スライス”**にする

って話なので、`context` が肝。

- `impact` が出した ID/doc の一覧をもとに、

  - 各 ID ブロックの **前後数行〜セクション全体**だけを抜粋
  - そこに Trace の該当行や DATA スキーマだけを添付
- その結果を
  「**この変更をかけたいので、矛盾しないように書き換えて**」
  と LLM に投げる。

ここまで行くと、ほんとに

> 「仕様の集合自身が、“この変更の影響”を `impact+context` で教えてくれる」
> LLM はその“局所世界”だけ見て動けばいい

という状態に近づく。

#### 4. iori-spec 的には何を実装すると一歩近づくか

このビジョンに一番近づくミニマム実装は、多分この順：

1. **今の index / trace を前提に、素朴な `impact <ID>` を作る**

   - ひとまず「直接つながっている ID ＋その定義 doc」の一覧を出すだけでもいい

2. その次に **操作種別を意識したパターンを足す**

   - `--op change`：直接 neighbors
   - `--op delete`：依存してくる側（入次数）を重視
   - `--op add`：同じ kind/scope の既存ノード

3. **簡易 `context` を作る**

   - `impact` が出した doc/line を使って、
   - Markdown 本文の該当セクション抜粋をテキストで返す

ここまでできると、
LLM に対してはほぼこういうやり方ができるようになる：

> 1. 人間「REQ-101 をこう変えたい」
> 2. ツール：`iori-spec impact --op change REQ-101 | context`
> 3. その出力を LLM に渡して「この範囲の整合性を保って修正して」と頼む

＝ **常に“小さい仕様”だけを見せる運用が現実的になる。**

## iori-spec のドキュメント構成（v1案）

### iori-spec の全体イメージ（概要）

- **必須**＝「iori-spec としてちゃんと効かせたいなら、基本ナシにしないほうがいい」
- **推奨**＝「小さく始めるなら省略可だが、少し育てるならほぼ必須級」
- **任意**＝「LLM 協調をガチでやるならあると嬉しい」
  というニュアンスで分類します。

- project-root/
  - docs/
    - README_SPEC.md     **必須**   # 仕様セットの地図
    - steering/          **推奨**   # ツールとしての目的・スコープ        ：なぜ・どこへ向かうか
    - requirements/      **必須**   # 機能・非機能 REQ（REQ-xxx）         ：何を実現するか
    - architecture/      **推奨**   # 全体構成・グラフモデル              ：どう組み立てるか
    - interfaces/        **推奨**   # CLI / API など（IF-xxx）            ：どう呼び出すか
    - data_contracts/    **推奨**   # 入出力 JSON/テキスト仕様（DATA-xxx）：どんな形のデータか
    - tests/             **推奨**   # どう検証するか（TEST-xxx）
    - reference/         **必須**   # 書き方ルール・用語・命名（LLM にも見せる前提）
    - dev_tasks/         **必須**   # IF ごとの開発タスク                 ：IF をどうタスクに分解するか
    - impl_notes/        任意       # 設計メモ・検討ログ（原則 LLM に見せない前提）

### iori-spec の全体イメージ（詳細）

- project-root/
  - docs/
    - README_SPEC.md                  # 仕様セットの地図

    - steering/                    # なぜ・どこへ向かうか
      - product.md                    # プロダクトの目的・背景・スコープ／非スコープ・成功指標

    - requirements/                # 何を実現するか（REQ-xxx）
      - functional.md                 # 機能要件（REQ-0xx）
      - nonfunctional.md              # 非機能要件（REQ-2xx）
      - traceability_map.md           # REQ ↔ IF/DATA/TEST 対応表

    - architecture/                # どう組み立てるか
      - overview.md                   # 全体アーキテクチャ（レイヤー構成など）

    - interfaces/                  # どう呼び出すか（IF-xxx）
      - cli/
        - IF-001_main_cli_spec.md     # 例：メイン CLI の IF 仕様（プロジェクトに応じて増える）
                                      # api/, job/, adapter/ などを増やしてよい

    - data_contracts/              # どんな形のデータか（DATA-xxx）
      - DATA-001_index_json.md        # 例：index 出力 JSON など

    - tests/                       # どう検証するか（TEST-xxx）
      - TEST-001_cli_smoke.md         # 例：基本的な受け入れテスト

    - reference/                   # 書き方ルール・用語・命名（LLMにも見せる前提）
      - iori_spec_guide.md                  # 仕様の書き方・front matter のフォーマット・IDルール
      - spec_structure_and_traceability.md  # 仕様構造とトレースのルール
      - naming_conventions.md         # 命名規則
      - glossary_jp_en.md             # 頻出用語の定義と日英対応

    - dev_tasks/                   # IF を実装するために必要なタスク
      - IF-001_main_cli_tasks.md      # IF-001 を実装するための TASK 群

    - impl_notes/                  # 裏メモ・検討ログ（デフォでは LLM に渡さない前提）
      - design_notes.md               # 設計の意図・議論ログ・TODO

### iori-spec のテンプレートファイル一覧

#### 1. トップレベル

| パス                    | 必須/任意 | 説明                                     |
| --------------------- | ----- | -------------------------------------- |
| `docs/`               | 必須    | 仕様のルート。iori-spec のコマンドはここを起点にスキャンする前提。 |
| `docs/README_SPEC.md` | 必須    | 仕様セットの「地図」。LLM に最初に読ませる入口としても使う。       |

#### 2. steering/

| パス                         | 必須/任意  | 説明                                                         |
| -------------------------- | ------ | ---------------------------------------------------------- |
| `docs/steering/`           | **推奨** | プロダクトの目的・背景・スコープ用。小規模おもちゃプロジェクトなら省略可だが、ちゃんと開発するならあったほうがいい。 |
| `docs/steering/product.md` | **推奨** | Vision / Scope / 非スコープを書く標準テンプレ。                           |

#### 3. requirements/

この辺は iori-spec 的にかなり重要です。

| パス                                      | 必須/任意  | 説明                                                 |
| --------------------------------------- | ------ | -------------------------------------------------- |
| `docs/requirements/`                    | **必須** | 「何を実現するか」の正本置き場。                                   |
| `docs/requirements/functional.md`       | **必須** | 機能要件 REQ-0xx。ここがないと「何をするプロダクトか」が定まらない。               |
| `docs/requirements/nonfunctional.md`    | **推奨** | 性能・信頼性など。超小規模プロダクトなら README_SPEC に混ぜてもよいが、分けたほうが後々楽。 |
| `docs/requirements/traceability_map.md` | **必須** | REQ ↔ IF/DATA/TEST をつなぐ SSOT。`trace` コマンドがここ前提で動く。 |

#### 4. architecture/

| パス                              | 必須/任意  | 説明                                 |
| ------------------------------- | ------ | ---------------------------------- |
| `docs/architecture/`            | **推奨** | システム構造・レイヤー・依存方向の話。                |
| `docs/architecture/overview.md` | **推奨** | レイヤー構成や主要コンポーネントの概要。中〜大規模なら事実上必須級。 |

（他に `components.md` や `build_pipeline.md` を足すのは**任意**）

#### 5. interfaces/

「対外インターフェイスが存在するなら」ほぼ必須、という扱い。

| パス                                            | 必須/任意     | 説明                        |
| --------------------------------------------- | --------- | ------------------------- |
| `docs/interfaces/`                            | **推奨**（※） | CLI / API など、外から叩く口の仕様。   |
| `docs/interfaces/cli/IF-001_main_cli_spec.md` | **推奨**    | CLI があるなら、その代表IFはここに書く前提。 |

※ 極端な話「バッチ処理 1 個だけ」「内部スクリプトでしか使わない」なら、当面はなくても動く。ただし「CLI や API があるツール」を iori-spec で見るなら、長期的には **interfaces/ ありき**で設計した方がトレースが綺麗に回ります。

#### 6. data_contracts/

| パス                                  | 必須/任意  | 説明                                             |
| ----------------------------------- | ------ | ---------------------------------------------- |
| `docs/data_contracts/`              | **推奨** | JSON やバイナリなど「データ形式」の正本。                        |
| `docs/data_contracts/DATA-001_*.md` | **推奨** | 何かしら構造化データを入出力するなら、その DATA-xxx は基本ここで定義しておきたい。 |

- 「標準出力にテキスト1行出すだけ」の超シンプルな CLI なら、最初はナシでも動きはする。
- でも **LLM にとっては「データ構造が specs にある」ほうが圧倒的に扱いやすい**ので、早めに切り出しておくのを推奨。

#### 7. tests/

| パス                                 | 必須/任意  | 説明                                 |
| ---------------------------------- | ------ | ---------------------------------- |
| `docs/tests/`                      | **推奨** | 受け入れテスト（TEST-xxx）の正本。              |
| `docs/tests/TEST-001_cli_smoke.md` | **推奨** | 「最低限これが通れば OK」というスモークテスト。最初の1枚として。 |

- 最小構成で「とりあえず iori-spec を試すだけ」なら省略もできるけど、
  **“仕様駆動” を名乗る以上は、どこかの段階で `tests/` は生やした方がいい**位置づけ。

#### 8. reference/

ここは iori-spec と LLM 両方にとってかなり重要です。

| パス                                                  | 必須/任意  | 説明                                                               |
| --------------------------------------------------- | ------ | ---------------------------------------------------------------- |
| `docs/reference/`                                   | **必須** | 仕様を書くためのルール・用語・命名のハブ。                     |
| `docs/reference/iori_spec_guide.md`                       | **必須** | ID ルール、front matter、各ディレクトリの役割など「メタ仕様」。                          |
| `docs/reference/spec_structure_and_traceability.md` | **必須** | REQ/IF/DATA/TEST/TASK の関係や、トレース・依存グラフのルール。`index` / `trace` の前提。 |
| `docs/reference/naming_conventions.md`              | **推奨** | ファイル名・ID・ディレクトリなどの命名方針。                    |
| `docs/reference/glossary_jp_en.md`                  | **推奨** | 用語の定義と日英対応。プロジェクトが大きくなるほどありがたみ増。|

#### 9. dev_tasks/（LLM 協調開発モード）

| パス                                        | 必須/任意       | 説明                                  |
| ----------------------------------------- | ----------- | ----------------------------------- |
| `docs/dev_tasks/`                         | **任意〜強く推奨** | 「LLM にタスクを渡して実装してもらう」前提ならほぼ必須級の便利枠。 |
| `docs/dev_tasks/IF-001_main_cli_tasks.md` | **任意〜強く推奨** | 1 IF = 1 dev_tasks ファイル、というスタイルを推奨。 |

- **普通の「人間だけのプロジェクト」ならなくてもよい。**
- でも「LLM にコードを書かせる」前提なら、
  **ここに TASK-IF-xxx-yy でタスクカードを溜めると一気にやりやすくなる**ので、「LLM協調モード」では**強く推奨**くらいのポジション。

#### 10. impl_notes/（舞台裏メモ）

| パス                                | 必須/任意  | 説明                            |
| --------------------------------- | ------ | ----------------------------- |
| `docs/impl_notes/`                | **任意** | 裏メモ・検討ログ。完成後は LLM に渡さない前提。    |
| `docs/impl_notes/design_notes.md` | **任意** | 設計時の議論ログ・没案・TODO を書き散らすための場所。 |

- **「仕様セットとしての正本」と「考え中のメモ」を物理的に分けたい場合に使う」**枠。
- なくても動くけど、設計議論をガッツリやる場合には、かなり相性が良い場所。

#### 11. まとめ

- **ほぼ必須**

  - `docs/`
  - `docs/README_SPEC.md`
  - `requirements/functional.md`
  - `requirements/traceability_map.md`
  - `reference/iori_spec_guide.md`
  - `reference/spec_structure_and_traceability.md`

- **プロダクトとして育てるならぜひ欲しい（推奨）**

  - `steering/product.md`
  - `requirements/nonfunctional.md`
  - `architecture/overview.md`
  - `interfaces/`（何かしら IF があるなら）
  - `data_contracts/`（構造化データがあるなら）
  - `tests/`

- **LLMと本気で協調開発するなら強く推したい**

  - `dev_tasks/` 以下（IFごとの TASK 集）
  - `impl_notes/design_notes.md`（設計ログの避難場所）

こんな感じで「必須 / 推奨 / 任意」を切っておくと、
iori-spec の README 側にもそのまま載せやすいし、プロジェクトごとにどこまで採用するかも決めやすいと思います。

## 新しいドキュメントを追加・変更するときの指針

新しいドキュメントを追加・変更するときは、まずこれを考える：

**このドキュメントは「何についての話」か？**

- なぜやるか？（→ steering）
- 何を実現するか？（→ requirements）
- どう組み立てるか？（→ architecture）
- どう呼び出すか？（→ interfaces）
- どんなデータ形式か？（→ data_contracts）
- どう検証するか？（→ tests）
- どうタスクに分解して LLM/人間に振るか？（→ dev_tasks）
- どう書く／読む／命名するか？（→ reference）
- 単なる設計メモか？（→ impl_notes）

これに対応して、各ディレクトリをこう解釈します👇

### `steering/` — “なぜ・どこへ向かうか”

#### 役割（定性的な定義）

- プロジェクトとしての **方向性・目的・スコープ** をまとめる場所。
- 「このツールをなぜ作るのか」「何を優先し、何はやらないか」といった
  **意志決定の前提**を書く。

#### 入れるべき内容

- プロダクトとしての目的・背景・コンテキスト
- 想定ユーザー像／利用シナリオ
- スコープ／非スコープ
- 成功指標（何ができればこのツールは“成功”と言えるか）

#### 含めない方がいいもの

- REQ/IF/DATA/TEST の個別仕様
- 具体的な CLI オプションや JSON スキーマ
- 命名規則や用語集（これは `reference/` 向き）

#### 判断のガイド

> 「この文書は “仕様” というより “プロジェクトの方向性・意図” の話か？」

YES → `steering/`
NO → 他ディレクトリを検討

### `requirements/` — “何を実現するか”

#### 役割（定性的な定義）

- ツールが満たすべき **機能要件・非機能要件（REQ-xxx）** を定義する。
- 「何ができる必要があるか？」を、実装方法抜きで書く場所。

#### 入れるべき内容

- 機能要件（例：`iori-spec index` は何を保証するか）
- 非機能要件（性能・拡張性・UX など）
- 時間計算量・メモリ制約などの「ハード制約」
- Traceability Map（REQ ↔ IF/DATA/TEST の対応表）

#### 含めない方がいいもの

- 実装詳細（どのモジュールがどう動くか）
- JSON のフィールド一覧（これは data_contract）
- CLI コマンドのフラグ詳細（これは interfaces）

#### 判断のガイド

> 「これは“何をするか”を、実装抜きで語っているか？」

YES → `requirements/`
NO → `architecture/` or `interfaces/` などを検討

### `architecture/` — “どう組み立てるか（構造）”

#### 役割

- ツール全体の **構造・分解・依存関係** を説明する場所。
- 「どんなコンポーネントがいて、どう繋がっているか」を書く。

#### 入れるべき内容

- コンポーネント図／レイヤー構造
- Data–Process Graph（G_DP）・要求トレースグラフ（G_trace）などの「モデル」
- モジュール分割方針（loader / indexer / trace_checker / graph_builder / cli など）
- 依存方向のルール（どの層がどの層に依存してよいか）

#### 含めない方がいいもの

- 個々の CLI コマンドの仕様（それは `interfaces/cli`）
- JSON スキーマやファイル形式（それは `data_contracts/`）
- テストシナリオの詳細（それは `tests/`）

#### 判断のガイド

> 「これは“システム全体をどう分解し、どう繋げるか”の話か？」

YES → `architecture/`
NO → REQ や IF や DATA を検討

### `interfaces/` — “どう呼び出すか（外から見た挙動）”

#### 役割

- CLI や Python API など、**外部から見えるインターフェイス（IF-xxx）** の仕様を書く。
- 「どんなコマンド／関数があり、どんな引数・オプション・出力を持つか」という**契約**を定義。
- **外側との境界面（I/O とふるまいの契約）**に責任を持つレイヤー

#### 入れるべき内容

- CLI コマンド仕様（コマンド名・オプション・終了コード・標準出力の構造など）
- 内部モジュール API（必要な場合）の I/O と契約
- エラーコード、異常系の挙動
- パフォーマンスやリソースに関わる**契約としての制約**
  - 「時間計算量は O(N log N) 以下とする」
  - 「入力はストリーミングで処理し、全ファイルを一括でメモリに載せてはならない」など

#### 含めない方がいいもの

- 出力 JSON フォーマットのフィールド構造（それ自体は `data_contracts/`）

  - ただし IF 側から「どの DATA-xxx を返すか」を参照するのは OK。
- 具体的な実装アルゴリズム（それは impl_notes or 実装コード）

#### アルゴリズムに関する方針

- 原則：
  - interfaces は「外から見えるふるまい（インターフェイス）」を記述する場所なので、
    単なる「実装の都合」を書きすぎない。
- ただし例外として、
  - 性能要件を満たすために**アルゴリズムそのものが契約になる場合**
  - 将来の実装がこの手法を前提にしている場合
  には、**interfaces に守るべきアルゴリズム的制約を明示してよい**。
- その場合、次のようにnormative / non-normative を分ける：
  - Algorithm (normative):
    - 守らないと仕様違反になる制約（計算量、ストリーミング必須など）
  - Implementation Notes (non-normative):
    - 実装のためのガイド・例・LLM 向けのヒント（実際のコードに直結するような手順やテクニック）
- 実装のための具体的レシピ（LLM 用の「こう書け」レベルのノート）は、可能であれば impl_notes/ 側に逃がす。

#### 判断のガイド

> 「これは“ユーザーや他モジュールが叩く入口の契約”の話か？」

YES → `interfaces/`
NO → REQ or DATA or tests を検討

### `data_contracts/` — “どんな形のデータをやりとりするか”

#### 役割

- ファイル・JSON・バイナリなど、**データ形式（DATA-xxx）** の正本を書く場所。
- 「このコマンドの出力 JSON はこういう構造で、このフィールドはこういう意味」という話。

#### 入れるべき内容

- `index` コマンドの JSON スキーマ
- `trace` レポートの構造（errors/warnings の配列など）
- `impact` / `context` の出力形式
- 将来他ツールと連携する場合のファイルフォーマット仕様

#### 含めない方がいいもの

- そのデータをどう使うか／どう生成するか（IF/architecture 側の話）
- 試行錯誤のメモや暫定案（impl_notes 向き）

#### 判断のガイド

> 「これは“データの入れ物（スキーマ）そのもの”を定義しているか？」

YES → `data_contracts/`
NO → IFやtestsやimpl_notesを検討

### `tests/` — “どう検証するか”

#### 役割

- 受け入れテストや結合テストレベルの **TEST-xxx** を定義する場所。
- 「どんな前提・入力で、どんな出力や状態を確認すべきか」を書く。

#### 入れるべき内容

- CLI レベルのテストシナリオ
- 仕様の受け入れ条件（Acceptance Criteria）詳細
- 実際のテストデータセットの説明（小さい例で OK）

#### 含めない方がいいもの

- ユニットテストコードの具体的な実装（それはコード側）
- 高レベルな「何を実現するか」（それは REQ 側）

#### 判断のガイド

> 「これは“どうなっていれば仕様を満たしたとみなすか”の具体例か？」

YES → `tests/`
NO → REQ or IF を検討

### `reference/` — “仕様を書く・読むための共通前提”

#### 役割

- 仕様そのものではなく、**仕様を書く／読む／命名するためのルール・辞書** を置く場所。
- LLM にもそのまま見せたい「メタ情報・ガイド」のハブ。

#### 入れるべき内容

- `iori_spec_guide.md`：仕様の書き方・ID ルール・構造
- `spec_structure_and_traceability.md`：今回決めた「spec/trace のルール」
- `naming_conventions.md`：命名規則
- `glossary_jp_en.md`：用語集・訳語の統一

#### 含めない方がいいもの

- 個別 REQ/IF/DATA/TEST の定義
- 設計メモ・ボツ案・TODO（それは impl_notes）

#### 判断のガイド

> 「これは“仕様の中身”ではなく、“仕様を書くルールや共通の用語”の話か？」

YES → `reference/`
NO → steering / requirements / architecture / impl_notes などを検討

### `dev_tasks/` — “どうタスクに分解して LLM/人間に振るか”

#### 役割

- 各 IF-xxx の実装を、**LLM / 人間がそのまま着手できる粒度のタスク**に分解した「開発タスクカード」を置く場所。
- 1 IF = 1 ファイルを基本とし、ファイル内で `TASK-IF-xxx-yy` を複数定義する。
- REQ / IF / DATA / TEST のような**プロダクト仕様の SSOT ではなく**、
  「**その仕様をどう開発タスクに落とし込むか**」を記述する補助レイヤー。

#### 入れるべき内容

- 各 IF-xxx ごとのタスク設計（例：`docs/dev_tasks/IF-001_index_tasks.md`）

  - 対象 IF / 関連 REQ の概要（Overview）
  - Task List（`TASK-IF-001-01` などの一覧と一言説明）
  - 各 TASK セクション（LLM にそのまま投げられるレベルの詳細）

    - 目的
    - 関連する IF / REQ / DATA / TEST
    - 入力 / 出力
    - 守るべき制約（計算量・メモリ・ライブラリ縛りなど）
    - 推奨手順・実装ステップ（LLM にやらせたい粒度の「やることリスト」）
- TASK ID の体系と意味

  - `TASK-IF-<nnn>-<mm>` という ID 形式の説明
  - 1 つの IF に対してどの TASK 群がぶら下がっているかの整理

#### 含めない方がいいもの

- REQ / IF / DATA / TEST としての**正式な仕様変更**

  - たとえば「IF-100 の挙動を A→B に変える」といった内容は、
    最終的には `interfaces/` や `requirements/` に反映されるべき。
- 仕様の SSOT として扱いたい表現

  - dev_tasks は「実装フローのための補助ノート」であり、
    REQ / IF / DATA / TEST の定義をここだけに閉じ込めない。
- 単なる思いつきメモ・ボツ案・雑多な検討ログ

  - それは `impl_notes/` 向き（「舞台裏メモ」のほうに寄せる）。

#### 判断のガイド

> 「これは“仕様そのもの”というより、**IF や REQ を“誰かに実装してもらうためのタスク”に割る話か？**」

- YES →

  - `dev_tasks/` を検討する。
  - 対応する IF-xxx ごとにファイルを作り、`TASK-IF-xxx-yy` として整理する。
- NO →

  - まず REQ / IF / DATA / TEST などの**本体仕様**に属さないかを検討し、
  - それでも違うなら `reference/`（ルール・用語）や `impl_notes/`（メモ）を検討する。

### `impl_notes/` — “設計メモ・TODO・ドラフト置き場”

#### 役割

- **設計の意図・検討中の案・ボツ案・TODO** を気楽に書き散らすための場所。
- 完成版の iori-spec では LLM に渡さない前提の、**裏側ノート**。

#### 入れるべき内容

- `iori_spec_design_notes.md`（今回のやつ）

  - 仕様を決めるまでの議論のログ
  - 迷ったポイント・採用しなかった案
  - 今後の TODO、未決定事項
- 実験メモ（グラフ実装の試行、CLI UX の比較案など）
- 将来 README / README_SPEC に昇格させる前のラフ案

#### 含めない方がいいもの

- “ここが SSOT です” としたい仕様

  - それは requirements / architecture / interfaces / data_contracts / tests のいずれかに昇格させるべき

#### 判断のガイド

> 「これは“最終仕様”というより、“考え中のメモ・設計の舞台裏”か？」

YES → `impl_notes/`
NO → 他ディレクトリへ昇格させる

### 迷ったときの最終ジャッジのコツ

1. **まず「これはプロダクト仕様か？」を判定する**

   - REQ-xxx を定義／変更している → `requirements/`
   - IF-xxx（インターフェイスの契約）を定義／変更している → `interfaces/`
   - DATA-xxx（データ構造・フォーマット）を定義／変更している → `data_contracts/`
   - TEST-xxx（受け入れテスト・結合テスト）を定義／変更している → `tests/`

2. **プロダクト仕様でなければ、「タスク設計か？」を判定する**

   - ある IF / REQ / 機能ブロックを
     **LLM / 人間に実装してもらうための「やることリスト」に分解している話か？**
   - `TASK-IF-xxx-yy` のようなタスク ID を付けたい／付けているか？

   → YES の場合：`dev_tasks/`
   （例：`docs/dev_tasks/IF-001_index_tasks.md` に TASK-IF-001-01〜 を書く）

3. **どれでもない場合：メタ or メモ系を判定する**

   - 「プロジェクトの方向性・目的・スコープ」の話 → `steering/`
   - 「仕様を書くルール・用語・命名」の話 → `reference/`
   - 「考え中のメモ／検討ログ／ボツ案／TODO」の話 → `impl_notes/`

4. **1つに収まらないと感じたら：分割 or 昇格を検討する**

   - 「どれが SSOT（正本）として一番自然か？」を考える
   - もしくは **2つに分割する**（例）：

     - 要件として残したい部分 → `requirements/`
     - その要件に至るまでの経緯や迷い → `impl_notes/`
     - IF の仕様として安定してきた話 → `interfaces/` に昇格
     - 実装タスクとして切り出したい話 → `dev_tasks/` に分離

## テンプレートを利用して iori-spec を実装するためのメモ

### 1. steering（推奨）

- docs/steering/product.md  
  - 役割: iori-spec の目的・対象ユーザ・スコープ・非ゴール
  - 主なトピック:
    - 「LLM＋スクリプトで仕様レビューを強化する」コンセプト
    - 想定ユーザ（自分＋将来のチーム）
    - 他ツールとの差別化（textlint や静的解析との違い）

※ steering は後回しでもよい。「なぜこのツールを作るか」を整理したくなったら追加する

### 2. requirements

- docs/requirements/functional.md  
  - kind: requirements / scope: functional  
  - 内容:
    - REQ-101〜: `index` コマンドの要求（ID 抽出・doc 一覧など）
    - REQ-111〜: `trace` コマンドの要求（未トレース検出など）
    - REQ-121〜: `impact` コマンドの要求（影響範囲抽出）
    - REQ-131〜: `context` コマンドの要求（LLM 向けコンテキスト生成）
    - REQ-150〜: LLM 協調（トークン節約・出力形式の一貫性）

- docs/requirements/nonfunctional.md  
  - kind: requirements / scope: nonfunctional  
  - 内容:
    - REQ-201〜: パフォーマンス（数百ファイルでも実用的）
    - REQ-202〜: トークン節約（出力のコンパクトさ）
    - REQ-203〜: 拡張性（ID プレフィックス追加への対応）
    - REQ-211〜: UX（CLI の一貫したオプション設計など）

- docs/requirements/traceability_map.md  
  - REQ ↔ IF / DATA / TEST の対応表（iori-spec 自身のトレーサビリティ）

### 3. architecture（推奨）

- docs/architecture/overview.md  
  - 役割: iori-spec の高レベルアーキテクチャ
  - 内容:
    - コンポーネント:
      - spec_loader（front matter / MD 読み込み）
      - id_indexer（ID 抽出 & index.json 生成）
      - trace_checker（trace 行と照合）
      - graph_builder（G_trace / G_DP / G_doc 構築）
      - cli（`index/trace/impact/context` の薄いラッパ）
    - 依存方向:
      - loader → indexer → graph_builder → trace_checker → cli
    - Data–Process Graph（DATA/IF ノード＋有向二部グラフ）の位置づけ

- docs/architecture/graphs_and_models.md  
  - 役割: G_trace / G_DP / G_doc の定義をまとめる
  - 内容:
    - 各グラフのノード・エッジ定義
    - どのコマンドがどのグラフを使うか
    - DAG 要件・循環検出方針など

※ v0 では overview にある程度まとめて、必要になったら分割でも OK。

### 4. interfaces（推奨）

#### 4.1 CLI インターフェイス

- docs/interfaces/cli/IF-001_index_cli_spec.md  
  - `iori-spec index <root> [--format json]` の仕様
- docs/interfaces/cli/IF-002_trace_cli_spec.md  
  - `iori-spec trace <root>` の仕様（エラー/警告分類など）
- docs/interfaces/cli/IF-003_impact_cli_spec.md  
  - `iori-spec impact <ID> [--hops N] [--format json]`
- docs/interfaces/cli/IF-004_context_cli_spec.md  
  - `iori-spec context <ID...> [--format text]`

※ v0 では `cli_spec.md` 1ファイルにまとめて、章ごとに IF-001〜004 でも良い。

#### 4.2 内部 Python API（必要になったら）

- docs/interfaces/python/IF-010_index_module_spec.md  
- docs/interfaces/python/IF-020_trace_module_spec.md  

など、CLI から呼び出すコア関数の仕様を切り出す余地。

### 5. data_contracts（推奨）

- docs/data_contracts/index_json.md  
  - DATA-101: `index` コマンドの JSON 出力スキーマ
  - docs 配列、ids 配列、行番号の表現など

- docs/data_contracts/trace_report.md  
  - DATA-111: `trace` コマンドのレポートフォーマット（エラー/警告一覧）

- docs/data_contracts/impact_json.md  
  - DATA-121: `impact` の出力（seed_ids / upstream / downstream / docs など）

- docs/data_contracts/context_bundle.md  
  - DATA-131: `context` のテキスト/JSON 形式（doc ごとの抜粋・行範囲）

※ v0 では `data_contracts/cli_outputs.md` に全部まとめてもよい。  
　後から DATA-xxx ごとに分割しやすいように見出しレベルだけ意識しておく。

### 6. tests（推奨）

- docs/tests/TEST-001_index_basic.md  
  - 小さな docs/ を用意して `index` で期待どおりの JSON が出るか
- docs/tests/TEST-011_trace_unmapped_ids.md  
  - Trace に載っていない ID を検出できるか
- docs/tests/TEST-021_impact_hops_limit.md  
  - hops を変えたときの影響範囲の広がり具合
- docs/tests/TEST-031_context_llm_friendly.md  
  - context 出力が LLM にとって読解しやすいフォーマットになっているか

※ 最初は 2〜3 個のテストシナリオから始めて、必要に応じて増やすイメージ。

### 7. dev_tasks（任意）

- docs/dev_tasks/IF-001_index_tasks.md  
  - IF-001（index CLI）のための開発タスクカード（TASK-IF-001-xx）をまとめたファイル

### 8. reference

- docs/reference/spec_structure_and_traceability.md

  - 「Spec Structure & Traceability Rules」
  - iori-spec が前提とする spec セットの構造・トレースルールを定義

- docs/reference/iori_spec_guide.md（必要なら）

  - 「iori-spec の仕様書自体」を書くためのルール
  - 既存プロジェクトの iori_spec_guide を再利用しつつ、iori-spec 特有の補足を加えるイメージ

- docs/reference/dev_tasks_spec.md

  - dev_tasks / TASK-xxx の仕様ルール

### 9. impl_notes（任意）

- docs/impl_notes/iori_spec_design_notes.md（このファイル）

  - 仕様を決めるまでの議論のログ
  - 迷ったポイント・採用しなかった案
  - 今後の TODO、未決定事項
- docs/impl_notes/experiments_*.md（必要になれば）

  - Graph 実装の試行や、CLI UX の比較案などを好きに書き散らす用。

##

------------------------------------------------------------------------------------------------

## MEMO

### 肥大化・複雑化したシステム・仕様において LLM の能力が低下する要因

- A. 関連ドキュメントの「見落とし」

  - **何が起きてる？**
    - REQ-101 を修正するとき、本当は IF-100 / DATA-101 / TEST-101 も見ないといけないのに、
      - どこにあるか分からない
      - そもそもファイルが多すぎて全部は読めない → 一部だけ読んで「だいたい合ってそう」な提案をする。

  - **具体例**
    - requirements/functional.md の REQ-101 を変更したのに、
      interfaces/digits/IF-100_*.md や data_contracts/by_digits_bin.md をコンテキストに含めず実装案を出す。
      → 実装は REQ-101 に整合してるけど、他の IF/DATA とズレる。

  - **ツールで埋めるべきところ**
    - index + trace + impact で、
      「REQ-101 に関連する IF / DATA / TEST / doc 一覧」を機械的に列挙して、その抜粋だけを LLM に渡す（context コマンド）。
    - 人間が「どのファイルを開くか」考えないで済むようにする。

- B. グローバル整合性（用語・ID・制約）の維持

  - **何が起きてる？**
    - 巨大仕様では、
      - 同じ概念を指す言葉が複数出てくる（例：digits index / by_digits / SURF_DIGITS…）
      - 似た REQ/IF が増える
    - LLM は「ローカルなテキスト」には強いけど、
      - 「リポジトリ全体で、この概念はどう定義されているか？」という **グローバルな一貫性チェック**は苦手。

  - **具体例**
    - REQ-101 の説明では「p95 ≤ 400ms」なのに、TEST-201 では「p95 ≤ 300ms」になっている。
      - どちらも文脈内では自然なので、
          LLM は「どっちが正？」を判断しきれず、片方を見落としてスルーしがち。

  - **ツールで埋めるべきところ**
    - `index` で ID と spec_title を集約し、
      - 「REQ-201: レイテンシ 400ms」
      - 「TEST-201: レイテンシ 300ms」
    - `trace` / `lint` で、
      - 同じ概念に見えるものの不一致（数値・単位・範囲など）を検出する余地。
    - 最低限、
      - 「この REQ に関する TEST はこれだけあります」「数値が食い違ってます」を **機械的に指摘**し、
          「どちらを正とすべきか？」みたいな判断だけ LLM に渡す。

- C. 複雑な依存関係（有向グラフ）の追跡

  - **何が起きてる？**
    - 多レイヤー構造（REQ→IF→DATA→IF→DATA…）になると、
      - 変更がどこまで波及するか
      - どこまで見れば「安心して変更できるか」
        の判断が人間でも難しくなる。
    - LLM は「一気に全部読む」ことはできても、
    - グラフとして**網羅的に探索**するのは苦手（探索漏れしがち）。

  - **具体例**
    - DATA-020（SURF_DIGITS）を変更したい。
    - 実際には
      - IF-040, IF-100 が DATA-020 に依存していて、
      - さらにその出力を使う別の IF/TEST もある。
    - にも関わらず LLM に「SURF_DIGITS の仕様をこう変えたい」とだけ指示すると、
        目の前のファイルの話だけ直して終わり、下流の影響が抜け落ちる。

  - **ツールで埋めるべきところ**
    - `Data–Process Graph (G_DP)` を構築しておき、
    - 「DATA-020 を起点にした下流ノード（IF / DATA / TEST / doc）」を `impact DATA-020` で出す。
    - LLM には「この一覧に出ているノードのうち、特に矛盾しそうなところをチェックして」と頼む。

- D. 設計の一貫性（パターン / テンプレート）の維持

  - **何が起きてる？**
    - 仕様が増えると、各 IF / DATA / TEST が「微妙に違う書き方」をし始める。
    - LLM は「そのファイルの中では」自然な文章を書くけど、
    - 別ファイルと並べたときにスタイル・構造・粒度が揃ってないことに自動では気づきづらい。

  - **具体例**
    - IF-001 は「概要 / Inputs / Outputs / Errors / Notes」の構成で書かれている。
    - あとから追加された IF-010 は、
      - 「Overview」と「Examples」はあるが、
      - Inputs の項目名が違う & Outputs が曖昧。
    - 単体で読めば OK だが、全体では気持ち悪い。

  - **ツールで埋めるべきところ**
    - `reference/iori_spec_guide.md` やテンプレートファイルでテンプレ定義（セクション構造）を明示。
    - 将来的に `lint` 的なコマンドで「IF-xxx はこの見出し構成を満たしているか？」をチェック。
    - LLM は、「テンプレに従って書き直して」「この lint の warning を解消して」という形で利用する。

- E. 長期セッションでの「状態喪失」と履歴管理

  - **何が起きてる？**
    - 会話が長くなると、
      - 「どこまで仕様を反映済みか」
      - 「どの REQ はもう実装済みで、どれが未着手か」
        が LLM の内部では曖昧になってくる。
    - LLM は「今のターンで見せられた情報」には強いけど、
    - リポジトリ全体の**進捗状態**を一貫して保持するのは苦手。

  - **具体例**
    - 「REQ-101 はもう実装済み」と話していたが、
        数日後の別セッションで LLM が「REQ-101 はまだだったかも…」的な提案をしてくる。

  - **ツールで埋めるべきところ**
    - 仕様そのものとは別に、
      - 「実装・タスクの進捗」は `dev_tasks/` などに ID 付きで管理する。
      - ある TASK-IF-001-01 が完了したら、`status: done` みたいに書き換える。
    - LLM には「最新の dev_tasks/ + index.json」を渡すことで、
        状態・進捗の“単一情報源”を与える。

- F. 複雑なリファクタリング / 全体変更の計画立案

  - **何が起きてる？**
    - 「仕様の方向性を変える」「ID 体系を整理し直す」みたいな大変更は、
      - 多くのファイルにまたがる
      - 「今の構造」を理解したうえで、「新しい構造」を提案する必要がある。
    - LLM は「ローカルな diff」には強いけど、
    - 多数のファイルにまたがる **変更計画**を組み立てるのは難しい。

  - **具体例**
    - REQ の ID を REQ-0xx → REQ-1xx に整理し直したい。
    - これに伴って複数ファイルの記述も変更が必要
      - 全 requirements,
      - traceability_map,
      - 各 IF/DATA/TEST
    - LLM に全ファイルを投げても「とりあえずこのファイルをこう直しましょう」レベルで終わってしまいがち。

  - **ツールで埋めるべきところ**
    - `index` で ID → 出現箇所の一覧を持っているので、
    - 「REQ-0xx をすべて列挙」「出現箇所の docs/line 一覧」
        をまずツールで出す。
  - 将来的には：
    - `impact REQ-0xx` のようなコマンドで、
    - 「このレンジの ID 全体を rename したときに触るべき場所」を機械的に出す。
    - LLM には、その一覧を渡して
      - 「この rename を安全に行うためのステップバイステップ手順」
      - 「PR をどう分割するか」
        を考えてもらう。

#### まとめ：ツールが埋めるべき「穴」の全体像

ざっくり整理すると、巨大仕様で LLM が苦手になるのは：

1. **どこを見ればいいか分からない**（関連ファイル探索）
2. **全部を一貫して覚えていられない**（グローバル整合性）
3. **依存グラフを網羅的に追えない**（影響範囲の見落とし）
4. **パターン・テンプレの一貫性維持が難しい**（書き方のブレ）
5. **長期的な状態・進捗を保持できない**（タスク管理）
6. **大規模変更の計画を立てるのが苦手**（全体リファクタリング）

で、iori-spec が目指しているのは：

- 1〜3 → `index` / `trace` / `impact` / `context` / グラフ構築でカバー
- 4 → `reference/iori_spec_guide` + 将来の `lint` でカバー
- 5 → `dev_tasks/` + ID 化された TASK でカバー
- 6 → 1〜5 の組み合わせ + LLM への「計画立案タスク」として投げる

という形になる。
もしこの中で「一番先に潰したい穴はどれ？」って聞かれたら、
個人的には **A（関連ドキュメントの見落とし）と C（依存グラフ）** からやると、
「小さいプロダクト並みに LLM が振る舞えるゾーン」が一気に広がると思う。

## コマンドの検討

### context コマンド

iori-spec で想定してる context コマンド（仮）の動きを、ざっくり擬似コードにするとこんなイメージです：

#### 例: 「REQ-101 を LLM に渡すための context を作って」と頼まれた場合

1. REQ-101 が載っているファイルを特定
2. そのファイルを開く
3. まず必ず front matter を読む
4. 次に必ず LLM_BRIEF を読む   ← ここが「**起点**」
5. 必要なら READ_NEXT を見て関連ファイル候補を集める ← これも「**起点**」
6. REQ-101 ブロック本体を読む（見出し / MACHINE_TAGS / Summary / …）
7. MACHINE_TAGS に書かれた rel-IF / rel-DATA / rel-TEST から、
   追加で読むべき IF/DATA/TEST を辿る
8. 集めたテキストをまとめて「LLM に渡す context」として組み立てる

## TODO

[x] iori_spec_design_notes に iori-spec のフォルダ構成を記載

[ ] iori_spec_design_notes には 含まれるドキュメントの一覧、各ドキュメントのテンプレートの書式、
    ドキュメントの機械的チェックの内容（もしくはその検討過程）を記載したい（ここでは検討過程、設計意図を含めてできるだけ情報の漏れがないように記録する）

[ ] iori_spec_design_notes に含まれる情報のうち、iori-spec の README や How to Use に記載すべき情報だけを精査して、README や How to Use を作成する

[ ] [Spec Structure & Traceability Rules / 2.2 trace_role（トレース上の役割）]
    ファイルの front matter のフォーマットにおいて、`trace_role` は、`kind`・`scope`・パス規則（ディレクトリ階層）から `iori-spec` が機械的に決定し、
    ユーザーが明示的に設定する必要はないが、将来的に上書き設定を許可する可能性の検討。



